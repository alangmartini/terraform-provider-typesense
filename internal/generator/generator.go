package generator

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/alanm/terraform-provider-typesense/internal/client"
	"github.com/alanm/terraform-provider-typesense/internal/version"
	"github.com/hashicorp/hcl/v2/hclwrite"
)

// Config holds the configuration for the generator
type Config struct {
	// Server connection
	Host     string
	Port     int
	Protocol string
	APIKey   string

	// Cloud connection
	CloudAPIKey string

	// Output settings
	OutputDir string

	// Data export settings
	IncludeData bool
}

// Generator handles the Terraform configuration generation
type Generator struct {
	config         *Config
	serverClient   *client.ServerClient
	cloudClient    *client.CloudClient
	serverVersion  *version.Version
	featureChecker version.FeatureChecker
}

// New creates a new Generator with the given configuration
func New(cfg *Config) *Generator {
	g := &Generator{
		config:         cfg,
		featureChecker: version.NewFallbackFeatureChecker(),
	}

	if cfg.Host != "" && cfg.APIKey != "" {
		g.serverClient = client.NewServerClient(cfg.Host, cfg.APIKey, cfg.Port, cfg.Protocol)
	}

	if cfg.CloudAPIKey != "" {
		g.cloudClient = client.NewCloudClient(cfg.CloudAPIKey)
	}

	return g
}

// DetectServerVersion queries the server and detects the version for feature-aware API selection.
// This should be called before Generate() for optimal API selection.
// On failure, it logs a warning and the generator will fall back to runtime detection.
func (g *Generator) DetectServerVersion(ctx context.Context) error {
	if g.serverClient == nil {
		return nil
	}

	info, err := g.serverClient.GetServerInfo(ctx)
	if err != nil {
		// Continue with fallback behavior
		fmt.Fprintf(os.Stderr, "Warning: Could not detect Typesense server version: %v\n", err)
		return nil
	}

	serverVersion, err := version.Parse(info.Version)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: Could not parse Typesense server version %q: %v\n", info.Version, err)
		return nil
	}

	g.serverVersion = serverVersion
	g.featureChecker = version.NewFeatureChecker(serverVersion)
	return nil
}

// Generate reads all resources and generates Terraform configuration
func (g *Generator) Generate(ctx context.Context) error {
	// Ensure output directory exists
	if err := os.MkdirAll(g.config.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create the main HCL file
	f := hclwrite.NewEmptyFile()

	// Add header comment
	headerComment := fmt.Sprintf("# Generated by terraform-provider-typesense generate\n# Source: %s://%s:%d\n# Generated at: %s\n\n",
		g.config.Protocol, g.config.Host, g.config.Port, time.Now().UTC().Format(time.RFC3339))
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte(headerComment)},
	})

	// Generate terraform block
	generateTerraformBlock(f)

	// Generate provider block
	generateProviderBlock(f, g.config.Host, g.config.Port, g.config.Protocol)

	// Track resource names for uniqueness
	resourceNames := make(map[string]bool)
	collectionResourceMap := make(map[string]string) // collection name -> resource name

	// Collect import commands
	var importCommands []ImportCommand

	// Generate cloud clusters if cloud client is available
	if g.cloudClient != nil {
		if err := g.generateClusters(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate clusters: %w", err)
		}
	}

	// Generate server resources if server client is available
	if g.serverClient != nil {
		// Collections first
		if err := g.generateCollections(ctx, f, resourceNames, collectionResourceMap, &importCommands); err != nil {
			return fmt.Errorf("failed to generate collections: %w", err)
		}

		// Stopwords sets
		if err := g.generateStopwords(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate stopwords: %w", err)
		}

		// Synonyms (depend on collections)
		if err := g.generateSynonyms(ctx, f, resourceNames, collectionResourceMap, &importCommands); err != nil {
			return fmt.Errorf("failed to generate synonyms: %w", err)
		}

		// Overrides (depend on collections)
		if err := g.generateOverrides(ctx, f, resourceNames, collectionResourceMap, &importCommands); err != nil {
			return fmt.Errorf("failed to generate overrides: %w", err)
		}

		// Analytics rules (may reference collections)
		if err := g.generateAnalyticsRules(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate analytics rules: %w", err)
		}

		// API keys
		if err := g.generateAPIKeys(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate API keys: %w", err)
		}

		// NL search models
		if err := g.generateNLSearchModels(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate NL search models: %w", err)
		}

		// Conversation models
		if err := g.generateConversationModels(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate conversation models: %w", err)
		}
	}

	// Write main.tf
	mainTFPath := filepath.Join(g.config.OutputDir, "main.tf")
	if err := os.WriteFile(mainTFPath, f.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write main.tf: %w", err)
	}

	// Write imports.sh
	importsPath := filepath.Join(g.config.OutputDir, "imports.sh")
	importScript := GenerateImportScript(importCommands)
	if err := os.WriteFile(importsPath, []byte(importScript), 0755); err != nil {
		return fmt.Errorf("failed to write imports.sh: %w", err)
	}

	return nil
}

func (g *Generator) generateClusters(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	clusters, err := g.cloudClient.ListClusters(ctx)
	if err != nil {
		return err
	}

	if len(clusters) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# CLUSTERS\n# ============================================\n\n")},
	})

	for _, cluster := range clusters {
		resourceName := MakeUniqueResourceName(cluster.Name, resourceNames)
		block := generateClusterBlock(&cluster, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_cluster",
			ResourceName: resourceName,
			ImportID:     ClusterImportID(cluster.ID),
		})
	}

	return nil
}

func (g *Generator) generateCollections(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	collections, err := g.serverClient.ListCollections(ctx)
	if err != nil {
		return err
	}

	if len(collections) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# COLLECTIONS\n# ============================================\n\n")},
	})

	for _, collection := range collections {
		resourceName := MakeUniqueResourceName(collection.Name, resourceNames)
		collectionResourceMap[collection.Name] = resourceName

		block := generateCollectionBlock(&collection, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_collection",
			ResourceName: resourceName,
			ImportID:     CollectionImportID(collection.Name),
		})

		// Export documents, synonyms, and overrides if data export is enabled
		if g.config.IncludeData {
			if err := g.exportDocuments(ctx, collection.Name); err != nil {
				return fmt.Errorf("failed to export documents for collection %s: %w", collection.Name, err)
			}

			// Export synonyms for this collection
			dataDir := filepath.Join(g.config.OutputDir, "data")
			if err := g.exportSynonyms(ctx, collection.Name, dataDir); err != nil {
				return fmt.Errorf("failed to export synonyms for collection %s: %w", collection.Name, err)
			}

			// Export overrides for this collection
			if err := g.exportOverrides(ctx, collection.Name, dataDir); err != nil {
				return fmt.Errorf("failed to export overrides for collection %s: %w", collection.Name, err)
			}
		}
	}

	return nil
}

func (g *Generator) generateStopwords(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	stopwordsSets, err := g.serverClient.ListStopwordsSets(ctx)
	if err != nil {
		return err
	}

	// Export stopwords data if data export is enabled (even if empty, creates the file)
	if g.config.IncludeData && len(stopwordsSets) > 0 {
		dataDir := filepath.Join(g.config.OutputDir, "data")
		if err := g.exportStopwordsSets(ctx, dataDir); err != nil {
			return fmt.Errorf("failed to export stopwords sets: %w", err)
		}
	}

	if len(stopwordsSets) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# STOPWORDS SETS\n# ============================================\n\n")},
	})

	for _, sw := range stopwordsSets {
		resourceName := MakeUniqueResourceName(sw.ID, resourceNames)
		block := generateStopwordsBlock(&sw, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_stopwords",
			ResourceName: resourceName,
			ImportID:     StopwordsImportID(sw.ID),
		})
	}

	return nil
}

func (g *Generator) generateSynonyms(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	// Use version-aware API selection
	if g.featureChecker.SupportsFeature(version.FeatureSynonymSets) {
		return g.generateSynonymSetsV30(ctx, f, resourceNames)
	}

	// For v29 and earlier, or when version detection failed (fallback)
	// Try per-collection synonyms first, fall back to synonym_sets if 404
	return g.generatePerCollectionSynonyms(ctx, f, resourceNames, collectionResourceMap, importCommands)
}

// generateSynonymSetsV30 handles synonym generation for Typesense v30.0+ using the /synonym_sets API
func (g *Generator) generateSynonymSetsV30(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool) error {
	synonymSets, err := g.serverClient.ListSynonymSets(ctx)
	if err != nil {
		return fmt.Errorf("failed to list synonym sets: %w", err)
	}

	if len(synonymSets) == 0 {
		return nil
	}

	// Add section header with version info
	versionStr := ""
	if g.serverVersion != nil {
		versionStr = fmt.Sprintf(" (detected server: v%s)", g.serverVersion.String())
	}
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte(fmt.Sprintf("# ============================================\n# SYNONYM SETS (Typesense v30.0+)%s\n# Note: Synonym sets are now system-level, not per-collection\n# ============================================\n\n", versionStr))},
	})

	for _, synSet := range synonymSets {
		resourceName := MakeUniqueResourceName("synonym_set_"+synSet.Name, resourceNames)
		// TODO: Generate synonym set blocks when the Terraform resource is implemented
		// For now, add a comment noting the synonym set exists
		comment := fmt.Sprintf("# Synonym set: %s (Terraform resource not yet implemented)\n\n", synSet.Name)
		f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: 4, Bytes: []byte(comment)},
		})
		_ = resourceName // Silence unused variable warning
	}

	return nil
}

// generatePerCollectionSynonyms handles synonym generation for Typesense v29 and earlier
// using the /collections/{name}/synonyms API
func (g *Generator) generatePerCollectionSynonyms(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	var allSynonyms []struct {
		synonym        client.Synonym
		collectionName string
	}

	collections, err := g.serverClient.ListCollections(ctx)
	if err != nil {
		return err
	}

	for _, collection := range collections {
		synonyms, err := g.serverClient.ListSynonyms(ctx, collection.Name)
		if err != nil {
			return fmt.Errorf("failed to list synonyms for collection %s: %w", collection.Name, err)
		}

		// If we get an empty list and version detection failed, it might be a v30+ server
		// The ListSynonyms method already handles 404 gracefully
		for _, syn := range synonyms {
			allSynonyms = append(allSynonyms, struct {
				synonym        client.Synonym
				collectionName string
			}{syn, collection.Name})
		}
	}

	if len(allSynonyms) == 0 {
		// If version detection failed and we got no synonyms, try the v30 API as fallback
		if g.serverVersion == nil {
			return g.generateSynonymSetsV30Fallback(ctx, f, resourceNames)
		}
		return nil
	}

	// Add section header with version info
	versionStr := ""
	if g.serverVersion != nil {
		versionStr = fmt.Sprintf(" (detected server: v%s)", g.serverVersion.String())
	}
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte(fmt.Sprintf("# ============================================\n# SYNONYMS%s\n# ============================================\n\n", versionStr))},
	})

	for _, item := range allSynonyms {
		collectionResourceName := collectionResourceMap[item.collectionName]
		resourceName := MakeUniqueResourceName(item.collectionName+"_"+item.synonym.ID, resourceNames)
		block := generateSynonymBlock(&item.synonym, collectionResourceName, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_synonym",
			ResourceName: resourceName,
			ImportID:     SynonymImportID(item.collectionName, item.synonym.ID),
		})
	}

	return nil
}

// generateSynonymSetsV30Fallback tries the v30 API when version detection failed
// and per-collection synonyms returned nothing
func (g *Generator) generateSynonymSetsV30Fallback(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool) error {
	synonymSets, err := g.serverClient.ListSynonymSets(ctx)
	if err != nil || synonymSets == nil || len(synonymSets) == 0 {
		// Either failed or no synonym sets - that's fine
		return nil
	}

	// Found synonym sets via fallback
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# SYNONYM SETS (Typesense v30.0+)\n# Note: Synonym sets are now system-level, not per-collection\n# ============================================\n\n")},
	})

	for _, synSet := range synonymSets {
		resourceName := MakeUniqueResourceName("synonym_set_"+synSet.Name, resourceNames)
		comment := fmt.Sprintf("# Synonym set: %s (Terraform resource not yet implemented)\n\n", synSet.Name)
		f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: 4, Bytes: []byte(comment)},
		})
		_ = resourceName
	}

	return nil
}

func (g *Generator) generateOverrides(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	// Use version-aware API selection
	if g.featureChecker.SupportsFeature(version.FeatureCurationSets) {
		return g.generateCurationSetsV30(ctx, f, resourceNames)
	}

	// For v29 and earlier, or when version detection failed (fallback)
	return g.generatePerCollectionOverrides(ctx, f, resourceNames, collectionResourceMap, importCommands)
}

// generateCurationSetsV30 handles override generation for Typesense v30.0+ using the /curation_sets API
func (g *Generator) generateCurationSetsV30(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool) error {
	curationSets, err := g.serverClient.ListCurationSets(ctx)
	if err != nil {
		return fmt.Errorf("failed to list curation sets: %w", err)
	}

	if len(curationSets) == 0 {
		return nil
	}

	// Add section header with version info
	versionStr := ""
	if g.serverVersion != nil {
		versionStr = fmt.Sprintf(" (detected server: v%s)", g.serverVersion.String())
	}
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte(fmt.Sprintf("# ============================================\n# CURATION SETS (Typesense v30.0+)%s\n# Note: Curation sets (formerly overrides) are now system-level, not per-collection\n# ============================================\n\n", versionStr))},
	})

	for _, curSet := range curationSets {
		resourceName := MakeUniqueResourceName("curation_set_"+curSet.Name, resourceNames)
		// TODO: Generate curation set blocks when the Terraform resource is implemented
		// For now, add a comment noting the curation set exists
		comment := fmt.Sprintf("# Curation set: %s (Terraform resource not yet implemented)\n\n", curSet.Name)
		f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: 4, Bytes: []byte(comment)},
		})
		_ = resourceName // Silence unused variable warning
	}

	return nil
}

// generatePerCollectionOverrides handles override generation for Typesense v29 and earlier
// using the /collections/{name}/overrides API
func (g *Generator) generatePerCollectionOverrides(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	var allOverrides []struct {
		override       client.Override
		collectionName string
	}

	collections, err := g.serverClient.ListCollections(ctx)
	if err != nil {
		return err
	}

	for _, collection := range collections {
		overrides, err := g.serverClient.ListOverrides(ctx, collection.Name)
		if err != nil {
			return fmt.Errorf("failed to list overrides for collection %s: %w", collection.Name, err)
		}

		// If we get an empty list and version detection failed, it might be a v30+ server
		// The ListOverrides method already handles 404 gracefully
		for _, ovr := range overrides {
			allOverrides = append(allOverrides, struct {
				override       client.Override
				collectionName string
			}{ovr, collection.Name})
		}
	}

	if len(allOverrides) == 0 {
		// If version detection failed and we got no overrides, try the v30 API as fallback
		if g.serverVersion == nil {
			return g.generateCurationSetsV30Fallback(ctx, f, resourceNames)
		}
		return nil
	}

	// Add section header with version info
	versionStr := ""
	if g.serverVersion != nil {
		versionStr = fmt.Sprintf(" (detected server: v%s)", g.serverVersion.String())
	}
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte(fmt.Sprintf("# ============================================\n# OVERRIDES%s\n# ============================================\n\n", versionStr))},
	})

	for _, item := range allOverrides {
		collectionResourceName := collectionResourceMap[item.collectionName]
		resourceName := MakeUniqueResourceName(item.collectionName+"_"+item.override.ID, resourceNames)
		block := generateOverrideBlock(&item.override, collectionResourceName, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_override",
			ResourceName: resourceName,
			ImportID:     OverrideImportID(item.collectionName, item.override.ID),
		})
	}

	return nil
}

// generateCurationSetsV30Fallback tries the v30 API when version detection failed
// and per-collection overrides returned nothing
func (g *Generator) generateCurationSetsV30Fallback(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool) error {
	curationSets, err := g.serverClient.ListCurationSets(ctx)
	if err != nil || curationSets == nil || len(curationSets) == 0 {
		// Either failed or no curation sets - that's fine
		return nil
	}

	// Found curation sets via fallback
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# CURATION SETS (Typesense v30.0+)\n# Note: Curation sets (formerly overrides) are now system-level, not per-collection\n# ============================================\n\n")},
	})

	for _, curSet := range curationSets {
		resourceName := MakeUniqueResourceName("curation_set_"+curSet.Name, resourceNames)
		comment := fmt.Sprintf("# Curation set: %s (Terraform resource not yet implemented)\n\n", curSet.Name)
		f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: 4, Bytes: []byte(comment)},
		})
		_ = resourceName
	}

	return nil
}

func (g *Generator) generateAnalyticsRules(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	rules, err := g.serverClient.ListAnalyticsRules(ctx)
	if err != nil {
		return err
	}

	if len(rules) == 0 {
		return nil
	}

	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# ANALYTICS RULES\n# ============================================\n\n")},
	})

	for _, rule := range rules {
		resourceName := MakeUniqueResourceName(rule.Name, resourceNames)
		block := generateAnalyticsRuleBlock(&rule, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_analytics_rule",
			ResourceName: resourceName,
			ImportID:     AnalyticsRuleImportID(rule.Name),
		})
	}

	return nil
}

func (g *Generator) generateAPIKeys(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	keys, err := g.serverClient.ListAPIKeys(ctx)
	if err != nil {
		return err
	}

	if len(keys) == 0 {
		return nil
	}

	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# API KEYS\n# ============================================\n\n")},
	})

	for _, key := range keys {
		name := key.Description
		if name == "" {
			name = fmt.Sprintf("key_%d", key.ID)
		}
		resourceName := MakeUniqueResourceName(name, resourceNames)
		block := generateAPIKeyBlock(&key, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_api_key",
			ResourceName: resourceName,
			ImportID:     APIKeyImportID(key.ID),
		})
	}

	return nil
}

func (g *Generator) generateNLSearchModels(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	models, err := g.serverClient.ListNLSearchModels(ctx)
	if err != nil {
		// NL search models may not be available on all server versions
		fmt.Fprintf(os.Stderr, "Warning: Could not list NL search models: %v\n", err)
		return nil
	}

	if len(models) == 0 {
		return nil
	}

	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# NL SEARCH MODELS\n# Note: api_key must be set via var.openai_api_key\n# ============================================\n\n")},
	})

	for _, model := range models {
		resourceName := MakeUniqueResourceName(model.ID, resourceNames)
		block := generateNLSearchModelBlock(&model, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_nl_search_model",
			ResourceName: resourceName,
			ImportID:     NLSearchModelImportID(model.ID),
		})
	}

	return nil
}

func (g *Generator) generateConversationModels(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	models, err := g.serverClient.ListConversationModels(ctx)
	if err != nil {
		// Conversation models may not be available on all server versions
		fmt.Fprintf(os.Stderr, "Warning: Could not list conversation models: %v\n", err)
		return nil
	}

	if len(models) == 0 {
		return nil
	}

	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# CONVERSATION MODELS\n# Note: api_key must be set via var.openai_api_key\n# ============================================\n\n")},
	})

	for _, model := range models {
		resourceName := MakeUniqueResourceName(model.ID, resourceNames)
		block := generateConversationModelBlock(&model, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_conversation_model",
			ResourceName: resourceName,
			ImportID:     ConversationModelImportID(model.ID),
		})
	}

	return nil
}

