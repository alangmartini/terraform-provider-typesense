package generator

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/alanm/terraform-provider-typesense/internal/client"
	"github.com/hashicorp/hcl/v2/hclwrite"
)

// Config holds the configuration for the generator
type Config struct {
	// Server connection
	Host     string
	Port     int
	Protocol string
	APIKey   string

	// Cloud connection
	CloudAPIKey string

	// Output settings
	OutputDir string
}

// Generator handles the Terraform configuration generation
type Generator struct {
	config       *Config
	serverClient *client.ServerClient
	cloudClient  *client.CloudClient
}

// New creates a new Generator with the given configuration
func New(cfg *Config) *Generator {
	g := &Generator{
		config: cfg,
	}

	if cfg.Host != "" && cfg.APIKey != "" {
		g.serverClient = client.NewServerClient(cfg.Host, cfg.APIKey, cfg.Port, cfg.Protocol)
	}

	if cfg.CloudAPIKey != "" {
		g.cloudClient = client.NewCloudClient(cfg.CloudAPIKey)
	}

	return g
}

// Generate reads all resources and generates Terraform configuration
func (g *Generator) Generate(ctx context.Context) error {
	// Ensure output directory exists
	if err := os.MkdirAll(g.config.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create the main HCL file
	f := hclwrite.NewEmptyFile()

	// Add header comment
	headerComment := fmt.Sprintf("# Generated by terraform-provider-typesense generate\n# Source: %s://%s:%d\n# Generated at: %s\n\n",
		g.config.Protocol, g.config.Host, g.config.Port, time.Now().UTC().Format(time.RFC3339))
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte(headerComment)},
	})

	// Generate terraform block
	generateTerraformBlock(f)

	// Generate provider block
	generateProviderBlock(f, g.config.Host, g.config.Port, g.config.Protocol)

	// Track resource names for uniqueness
	resourceNames := make(map[string]bool)
	collectionResourceMap := make(map[string]string) // collection name -> resource name

	// Collect import commands
	var importCommands []ImportCommand

	// Generate cloud clusters if cloud client is available
	if g.cloudClient != nil {
		if err := g.generateClusters(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate clusters: %w", err)
		}
	}

	// Generate server resources if server client is available
	if g.serverClient != nil {
		// Collections first
		if err := g.generateCollections(ctx, f, resourceNames, collectionResourceMap, &importCommands); err != nil {
			return fmt.Errorf("failed to generate collections: %w", err)
		}

		// Stopwords sets
		if err := g.generateStopwords(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate stopwords: %w", err)
		}

		// Synonyms (depend on collections)
		if err := g.generateSynonyms(ctx, f, resourceNames, collectionResourceMap, &importCommands); err != nil {
			return fmt.Errorf("failed to generate synonyms: %w", err)
		}

		// Overrides (depend on collections)
		if err := g.generateOverrides(ctx, f, resourceNames, collectionResourceMap, &importCommands); err != nil {
			return fmt.Errorf("failed to generate overrides: %w", err)
		}

		// API Keys (with warnings)
		if err := g.generateAPIKeys(ctx, f, resourceNames, &importCommands); err != nil {
			return fmt.Errorf("failed to generate API keys: %w", err)
		}
	}

	// Write main.tf
	mainTFPath := filepath.Join(g.config.OutputDir, "main.tf")
	if err := os.WriteFile(mainTFPath, f.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write main.tf: %w", err)
	}

	// Write imports.sh
	importsPath := filepath.Join(g.config.OutputDir, "imports.sh")
	importScript := GenerateImportScript(importCommands)
	if err := os.WriteFile(importsPath, []byte(importScript), 0755); err != nil {
		return fmt.Errorf("failed to write imports.sh: %w", err)
	}

	return nil
}

func (g *Generator) generateClusters(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	clusters, err := g.cloudClient.ListClusters(ctx)
	if err != nil {
		return err
	}

	if len(clusters) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# CLUSTERS\n# ============================================\n\n")},
	})

	for _, cluster := range clusters {
		resourceName := MakeUniqueResourceName(cluster.Name, resourceNames)
		block := generateClusterBlock(&cluster, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_cluster",
			ResourceName: resourceName,
			ImportID:     ClusterImportID(cluster.ID),
		})
	}

	return nil
}

func (g *Generator) generateCollections(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	collections, err := g.serverClient.ListCollections(ctx)
	if err != nil {
		return err
	}

	if len(collections) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# COLLECTIONS\n# ============================================\n\n")},
	})

	for _, collection := range collections {
		resourceName := MakeUniqueResourceName(collection.Name, resourceNames)
		collectionResourceMap[collection.Name] = resourceName

		block := generateCollectionBlock(&collection, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_collection",
			ResourceName: resourceName,
			ImportID:     CollectionImportID(collection.Name),
		})
	}

	return nil
}

func (g *Generator) generateStopwords(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	stopwordsSets, err := g.serverClient.ListStopwordsSets(ctx)
	if err != nil {
		return err
	}

	if len(stopwordsSets) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# STOPWORDS SETS\n# ============================================\n\n")},
	})

	for _, sw := range stopwordsSets {
		resourceName := MakeUniqueResourceName(sw.ID, resourceNames)
		block := generateStopwordsBlock(&sw, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_stopwords",
			ResourceName: resourceName,
			ImportID:     StopwordsImportID(sw.ID),
		})
	}

	return nil
}

func (g *Generator) generateSynonyms(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	var allSynonyms []struct {
		synonym        client.Synonym
		collectionName string
	}

	// First try the new synonym_sets API (Typesense v30.0+)
	synonymSets, err := g.serverClient.ListSynonymSets(ctx)
	if err != nil {
		return fmt.Errorf("failed to list synonym sets: %w", err)
	}

	if synonymSets != nil {
		// Using Typesense v30.0+ API - synonym sets are system-level, not per-collection
		if len(synonymSets) == 0 {
			return nil
		}

		// Add section header
		f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: 4, Bytes: []byte("# ============================================\n# SYNONYM SETS (Typesense v30.0+)\n# Note: Synonym sets are now system-level, not per-collection\n# ============================================\n\n")},
		})

		for _, synSet := range synonymSets {
			resourceName := MakeUniqueResourceName("synonym_set_"+synSet.Name, resourceNames)
			// TODO: Generate synonym set blocks when the Terraform resource is implemented
			// For now, add a comment noting the synonym set exists
			comment := fmt.Sprintf("# Synonym set: %s (Terraform resource not yet implemented)\n\n", synSet.Name)
			f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
				{Type: 4, Bytes: []byte(comment)},
			})
			_ = resourceName // Silence unused variable warning
		}

		return nil
	}

	// Fallback to old per-collection synonyms API (Typesense v29 and earlier)
	collections, err := g.serverClient.ListCollections(ctx)
	if err != nil {
		return err
	}

	for _, collection := range collections {
		synonyms, err := g.serverClient.ListSynonyms(ctx, collection.Name)
		if err != nil {
			return fmt.Errorf("failed to list synonyms for collection %s: %w", collection.Name, err)
		}
		for _, syn := range synonyms {
			allSynonyms = append(allSynonyms, struct {
				synonym        client.Synonym
				collectionName string
			}{syn, collection.Name})
		}
	}

	if len(allSynonyms) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# SYNONYMS\n# ============================================\n\n")},
	})

	for _, item := range allSynonyms {
		collectionResourceName := collectionResourceMap[item.collectionName]
		resourceName := MakeUniqueResourceName(item.collectionName+"_"+item.synonym.ID, resourceNames)
		block := generateSynonymBlock(&item.synonym, collectionResourceName, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_synonym",
			ResourceName: resourceName,
			ImportID:     SynonymImportID(item.collectionName, item.synonym.ID),
		})
	}

	return nil
}

func (g *Generator) generateOverrides(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, collectionResourceMap map[string]string, importCommands *[]ImportCommand) error {
	// First try the new curation_sets API (Typesense v30.0+)
	curationSets, err := g.serverClient.ListCurationSets(ctx)
	if err != nil {
		return fmt.Errorf("failed to list curation sets: %w", err)
	}

	if curationSets != nil {
		// Using Typesense v30.0+ API - curation sets are system-level, not per-collection
		if len(curationSets) == 0 {
			return nil
		}

		// Add section header
		f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: 4, Bytes: []byte("# ============================================\n# CURATION SETS (Typesense v30.0+)\n# Note: Curation sets (formerly overrides) are now system-level, not per-collection\n# ============================================\n\n")},
		})

		for _, curSet := range curationSets {
			resourceName := MakeUniqueResourceName("curation_set_"+curSet.Name, resourceNames)
			// TODO: Generate curation set blocks when the Terraform resource is implemented
			// For now, add a comment noting the curation set exists
			comment := fmt.Sprintf("# Curation set: %s (Terraform resource not yet implemented)\n\n", curSet.Name)
			f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
				{Type: 4, Bytes: []byte(comment)},
			})
			_ = resourceName // Silence unused variable warning
		}

		return nil
	}

	// Fallback to old per-collection overrides API (Typesense v29 and earlier)
	var allOverrides []struct {
		override       client.Override
		collectionName string
	}

	collections, err := g.serverClient.ListCollections(ctx)
	if err != nil {
		return err
	}

	for _, collection := range collections {
		overrides, err := g.serverClient.ListOverrides(ctx, collection.Name)
		if err != nil {
			return fmt.Errorf("failed to list overrides for collection %s: %w", collection.Name, err)
		}
		for _, ovr := range overrides {
			allOverrides = append(allOverrides, struct {
				override       client.Override
				collectionName string
			}{ovr, collection.Name})
		}
	}

	if len(allOverrides) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# OVERRIDES\n# ============================================\n\n")},
	})

	for _, item := range allOverrides {
		collectionResourceName := collectionResourceMap[item.collectionName]
		resourceName := MakeUniqueResourceName(item.collectionName+"_"+item.override.ID, resourceNames)
		block := generateOverrideBlock(&item.override, collectionResourceName, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_override",
			ResourceName: resourceName,
			ImportID:     OverrideImportID(item.collectionName, item.override.ID),
		})
	}

	return nil
}

func (g *Generator) generateAPIKeys(ctx context.Context, f *hclwrite.File, resourceNames map[string]bool, importCommands *[]ImportCommand) error {
	keys, err := g.serverClient.ListAPIKeys(ctx)
	if err != nil {
		return err
	}

	if len(keys) == 0 {
		return nil
	}

	// Add section header
	f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
		{Type: 4, Bytes: []byte("# ============================================\n# API KEYS\n# ============================================\n\n")},
	})

	for _, key := range keys {
		resourceName := MakeUniqueResourceName(fmt.Sprintf("key_%d", key.ID), resourceNames)

		// Add warning comment before the resource
		warning := generateAPIKeyComment(key.ID)
		f.Body().AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: 4, Bytes: []byte(warning)},
		})

		block := generateAPIKeyBlock(&key, resourceName)
		f.Body().AppendBlock(block)
		f.Body().AppendNewline()

		*importCommands = append(*importCommands, ImportCommand{
			ResourceType: "typesense_api_key",
			ResourceName: resourceName,
			ImportID:     APIKeyImportID(key.ID),
		})
	}

	return nil
}
